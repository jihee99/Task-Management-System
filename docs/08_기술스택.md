# 기술 스택 선정 및 선택 이유

## 1. 핵심 프레임워크

| 기술 | 버전 | 선택 이유 |
|:-----|:-----|:----------|
| **React** | 18.x | 명세 필수 요구사항. Concurrent Features, Suspense 활용 가능 |
| **TypeScript** | 5.x | 명세 필수 요구사항. strict 모드로 타입 안전성 극대화 |
| **Vite** | 5.x | 빠른 HMR, ESM 기반 번들링, CRA 대비 개발 경험 우수 |

### 1.1 TypeScript strict 모드

TypeScript는 `strict: true`를 기본으로 설정하여 타입 안전성을 극대화한다.

| 옵션 | 효과 |
|:-----|:-----|
| `strict: true` | 모든 strict 계열 옵션 활성화 |
| `noUncheckedIndexedAccess: true` | 배열/객체 인덱스 접근 시 `undefined` 가능성 포함 |

```typescript
// noUncheckedIndexedAccess 효과
const tasks: Task[] = response.data;
const first = tasks[0]; // 타입: Task | undefined (안전)
```

> **상세 설정**: `10_정적분석도구설정.md` 참조

### 1.2 Vite 선택 이유

| 비교 항목 | CRA | Vite |
|:----------|:----|:-----|
| 유지보수 상태 | ❌ 권장 중단 | ✅ 활발 |
| 개발 서버 시작 | 느림 | 빠름 (ESM 기반) |
| MSW 호환성 | 추가 설정 필요 | ✅ 우수 |
| 프로덕션 빌드 | Webpack | Rollup (최적화) |

---

## 2. 상태 관리

### 2.1 서버 상태 (Server State)

| 기술 | 선택 이유 |
|:-----|:----------|
| **TanStack Query** v5 | 무한 스크롤(`useInfiniteQuery`), 캐싱, 자동 리페칭 지원 |

**명세 요구사항 매핑**:

| 요구사항 | TanStack Query 기능 |
|:---------|:--------------------|
| "목록 끝에 도달 시 다음 페이지 API 호출" | `useInfiniteQuery` |
| 보호된 페이지 401 에러 시 공통 처리 | `onError` 글로벌 핸들러 (대시보드 제외) |
| 페이지별 데이터 재조회 | 자동 캐시 무효화 |

> 💡 **설계 결정**: 대시보드(`/`)는 401 시 리다이렉트하지 않고 페이지 레벨에서 로그인 유도 UI를 표시한다.

### 2.2 전역 상태 (Client State)

| 기술 | 선택 이유 |
|:-----|:----------|
| **Zustand** | 인증 상태(토큰, redirectPath) 관리. 보일러플레이트 최소 |

**Context API 대신 Zustand 선택 이유**:

| 비교 항목 | Context API | Zustand |
|:----------|:------------|:--------|
| 리렌더링 | 상태 변경 시 하위 전체 | selector 기반 부분 리렌더링 |
| 디버깅 | React DevTools | 전용 DevTools 지원 |
| 보일러플레이트 | Provider 래핑 필요 | 불필요 |
| 번들 크기 | 0 (내장) | ~2KB (경량) |

과제 규모에서는 Context API도 충분하나, Zustand를 선택한 핵심 이유:
1. **인증 상태 변경 시 불필요한 리렌더링 방지** (selector 패턴)
2. DevTools로 토큰 상태 디버깅 용이
3. 향후 상태 확장 시 마이그레이션 비용 없음

---

## 3. 라우팅

| 기술 | 버전 | 선택 이유 |
|:-----|:-----|:----------|
| **React Router** | v6.x | 사실상 표준, ProtectedRoute 구현 용이, 중첩 라우팅 지원 |

**핵심 활용**:

| Hook/컴포넌트 | 용도 |
|:--------------|:-----|
| `useNavigate` | 프로그래매틱 네비게이션 (보호된 페이지 401 리다이렉트) |
| `useLocation` | 현재 경로 저장 (redirectAfterLoginPath) |
| `useParams` | 동적 라우트 파라미터 (`/task/:id`) |
| `Outlet` | 레이아웃 중첩 (AppLayout 내 페이지 렌더링) |

> 💡 **설계 결정**: 대시보드(`/`)는 ProtectedRoute를 적용하지 않음. 비로그인 사용자도 접근 가능한 랜딩 페이지로 활용.

---

## 4. 폼 관리 및 유효성 검증

| 기술 | 선택 이유 |
|:-----|:----------|
| **React Hook Form** | 비제어 컴포넌트 기반으로 리렌더링 최소화, 유효성 검증 통합 |
| **Zod** | TypeScript 친화적 스키마 검증, React Hook Form과 완벽 호환 |

**명세 요구사항 매핑**:

| 요구사항 | 구현 방식 |
|:---------|:----------|
| 이메일: RFC 규약 검증 | `z.string().email()` |
| 비밀번호: 영문/한글/숫자, 8~24자 | `z.string().min().max().regex()` |
| 유효성 실패 시 에러 메시지 | `formState.errors` |
| 조건 충족 시에만 버튼 활성화 | `formState.isValid` |

**Zod 스키마 예시**:

```typescript
const signInSchema = z.object({
  email: z.string().email('올바른 이메일 형식이 아닙니다'),
  password: z
    .string()
    .min(8, '비밀번호는 8자 이상이어야 합니다')
    .max(24, '비밀번호는 24자 이하여야 합니다')
    .regex(/^[a-zA-Z가-힣0-9]+$/, '영문, 한글, 숫자만 사용 가능합니다'),
});
```

---

## 5. 가상 스크롤링

| 기술 | 선택 이유 |
|:-----|:----------|
| **@tanstack/react-virtual** | TanStack 생태계 통합, 경량, 무한 스크롤과 조합 용이 |

**대안 비교**:

| 라이브러리 | 장점 | 단점 | 선택 |
|:-----------|:-----|:-----|:-----|
| react-window | 안정적, 널리 사용 | 무한 스크롤 별도 구현 필요 | - |
| react-virtuoso | 무한 스크롤 내장 | 번들 크기 큼 (~15KB) | - |
| **@tanstack/react-virtual** | 경량 (~2KB), TanStack Query와 통합 | 약간의 추가 구현 필요 | ✅ |

**명세 요구사항**:
> "스크롤 영역에서 화면에 보여지는 요소 또는 보여질 요소에 대해서만 적절히 렌더링"

---

## 6. HTTP 클라이언트

| 기술 | 선택 이유 |
|:-----|:----------|
| **Axios** | 인터셉터 기반 401 처리, 요청/응답 변환, 타임아웃 설정 |

**fetch 대신 Axios 선택 이유**:

| 비교 항목 | fetch | Axios |
|:----------|:------|:------|
| 인터셉터 | 직접 래핑 필요 | ✅ 내장 |
| 보호된 페이지 401 공통 처리 | 모든 호출에 try-catch | Response Interceptor 1곳 (대시보드 제외 로직 포함) |
| 타임아웃 | AbortController 필요 | ✅ 옵션으로 설정 |
| JSON 변환 | 수동 (`res.json()`) | ✅ 자동 |

**핵심 활용**:

```typescript
// Request Interceptor: Authorization 헤더 자동 첨부
axiosInstance.interceptors.request.use((config) => {
  const token = useAuthStore.getState().accessToken;
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// Response Interceptor: 401 에러 처리 (대시보드 제외)
axiosInstance.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      const currentPath = window.location.pathname;
      
      // 💡 대시보드는 401 리다이렉트 제외 (랜딩 페이지)
      // 페이지 레벨에서 로그인 유도 UI 표시
      if (currentPath === '/') {
        return Promise.reject(error);
      }
      
      // 보호된 페이지: 즉시 로그인 리다이렉트
      // ...
    }
    return Promise.reject(error);
  }
);
```

---

## 7. API Mocking

| 기술 | 선택 이유 |
|:-----|:----------|
| **MSW (Mock Service Worker)** v2 | 네트워크 레벨 모킹, 실제 API와 동일한 요청/응답 흐름 |

**명세 요구사항**:
> "MSW / 함수 레벨 모킹 / Mock 서버 / 별도 서버 구축 중 1가지 이상 선택"

**MSW 선택 이유**:

| 장점 | 설명 |
|:-----|:-----|
| DevTools 확인 | 브라우저 Network 탭에서 요청/응답 확인 가능 |
| 코드 재사용 | 개발/테스트 환경에서 동일한 핸들러 사용 |
| 전환 비용 최소 | 실제 API 전환 시 핸들러만 제거 |

---

## 8. 스타일링

| 기술 | 선택 이유 |
|:-----|:----------|
| **Tailwind CSS** | 유틸리티 기반 빠른 개발, 디자인 토큰 커스터마이징 용이 |

**대안 비교**:

| 방식 | 장점 | 단점 | 선택 |
|:-----|:-----|:-----|:-----|
| CSS Modules | 스코프 격리, 러닝커브 낮음 | 클래스명 작성 반복 | - |
| styled-components | 동적 스타일링 | 런타임 오버헤드, 번들 증가 | - |
| **Tailwind CSS** | 빠른 개발, 일관성, 디자인 토큰 | 초기 학습 필요 | ✅ |

**디자인 토큰 적용** (명세 필수):

```javascript
// tailwind.config.js
module.exports = {
  theme: {
    extend: {
      colors: {
        primary: '#3B82F6',    // blue - 활성화 버튼
        disabled: '#9CA3AF',   // gray - 비활성화 버튼
      },
      fontFamily: {
        sans: ['Pretendard', 'sans-serif'],  // 필수
      },
    },
  },
};
```

---

## 9. 아이콘

| 기술 | 선택 이유 |
|:-----|:----------|
| **Lucide React** | 경량, Tree-shaking 지원, 일관된 디자인 |

**명세 요구사항**:
> "메뉴별 아이콘은 서로 겹치지 않게 지정"

**아이콘 매핑**:

| 위치 | 아이콘 | 컴포넌트 |
|:-----|:-------|:---------|
| 대시보드 | `LayoutDashboard` | `<LayoutDashboard />` |
| 할 일 | `CheckSquare` | `<CheckSquare />` |
| 로그인 | `LogIn` | `<LogIn />` |
| 회원정보 | `User` | `<User />` |
| 삭제 | `Trash2` | `<Trash2 />` |

---

## 10. 개발 도구

| 기술 | 용도 |
|:-----|:-----|
| **ESLint** | 코드 품질, 일관성 (명세 필수) |
| **Prettier** | 코드 포맷팅 (명세 필수) |

### 10.1 ESLint 버전 선택

| 버전 | 설정 방식 | 선택 |
|:-----|:----------|:-----|
| 9.x | Flat Config (`eslint.config.js`) | - |
| **8.x** | Legacy Config (`.eslintrc.cjs`) | ✅ |

**ESLint 8.x 선택 이유**:
- `eslint-plugin-react-hooks` 등 주요 플러그인의 Flat Config 지원 불완전
- 과제 기간 내 호환성 이슈 트러블슈팅 리스크 회피
- Legacy Config가 더 많은 레퍼런스 보유

> **상세 설정**: `10_정적분석도구설정.md` 참조

---

## 11. 기술 스택 요약

```
┌─────────────────────────────────────────────────────────────┐
│                    기술 스택 Overview                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Framework     : React 18 + TypeScript 5 (strict) + Vite    │
│                                                             │
│  Routing       : React Router v6                            │
│                                                             │
│  State         : Zustand (전역) + TanStack Query (서버)     │
│                                                             │
│  Form          : React Hook Form + Zod                      │
│                                                             │
│  HTTP          : Axios                                      │
│                                                             │
│  Virtualization: @tanstack/react-virtual                    │
│                                                             │
│  Styling       : Tailwind CSS + Pretendard                  │
│                                                             │
│  Icons         : Lucide React                               │
│                                                             │
│  Mocking       : MSW v2                                     │
│                                                             │
│  Tooling       : ESLint 8.x + Prettier                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 12. package.json 의존성

```json
{
  "dependencies": {
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.28.0",
    "@tanstack/react-query": "^5.60.0",
    "@tanstack/react-virtual": "^3.10.0",
    "zustand": "^5.0.0",
    "axios": "^1.7.0",
    "react-hook-form": "^7.53.0",
    "@hookform/resolvers": "^3.9.0",
    "zod": "^3.23.0",
    "lucide-react": "^0.460.0"
  },
  "devDependencies": {
    "typescript": "^5.6.0",
    "vite": "^5.4.0",
    "@vitejs/plugin-react": "^4.3.0",
    "tailwindcss": "^3.4.0",
    "postcss": "^8.4.0",
    "autoprefixer": "^10.4.0",
    "msw": "^2.6.0",
    "eslint": "^8.57.0",
    "@typescript-eslint/parser": "^7.0.0",
    "@typescript-eslint/eslint-plugin": "^7.0.0",
    "eslint-plugin-react": "^7.34.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-config-prettier": "^9.1.0",
    "prettier": "^3.3.0"
  }
}
```

---

## 13. 기술 선정 원칙

본 프로젝트의 기술 선정은 다음 원칙을 따랐다:

| 원칙 | 설명 |
|:-----|:-----|
| **명세 우선** | 필수 요구사항을 충족하는 기술 우선 선택 |
| **최소 구성** | 과제 범위에 필요한 기술만 포함, 과도한 설정 지양 |
| **선택 근거 명확** | 모든 기술에 "왜 선택했는가" 설명 가능 |
| **일관성** | TanStack 생태계(Query, Virtual) 등 동일 생태계 우선 |
| **안정성** | 검증된 버전 사용, 최신 버전의 호환성 이슈 회피 |

> **설계 철학**: "많이 넣기"가 아닌 "필요한 것만, 이유 있게"
