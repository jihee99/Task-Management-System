# 시스템 설계서

## 1. 개요

본 문서는 **할 일 관리 시스템(Task Management System)**의 프론트엔드 구현을 위한 기술 스택, 아키텍처, 상태 관리, 인증 흐름, 에러 처리 정책을 정의합니다.

---

## 2. 기술 스택

### 2.1 핵심 기술

| 영역    | 기술              | 선택 이유                 |
|:------|:----------------|:----------------------|
| 프레임워크 | React 18        | 명세 필수 요구사항            |
| 언어    | TypeScript      | 명세 필수 요구사항, 타입 안정성    |
| 빌드 도구 | Vite            | 빠른 HMR, MSW 호환성       |
| 라우팅   | React Router v6 | SPA 라우팅 표준, 중첩 라우트 지원 |

### 2.2 상태 관리

| 구분    | 기술                | 사용 범위              |
|:------|:------------------|:-------------------|
| 서버 상태 | TanStack Query v5 | API 응답 데이터, 무한 스크롤 |
| 전역 상태 | Zustand           | 인증 상태              |
| 로컬 상태 | useState          | 폼 입력, 모달 등 UI 상태   |

### 2.3 UI 및 성능

| 기술                      | 용도              |
|:------------------------|:----------------|
| Tailwind CSS            | 스타일링, 디자인 토큰 관리 |
| @tanstack/react-virtual | 가상 스크롤링 (명세 필수) |
| React Hook Form + Zod   | 폼 관리 및 유효성 검증   |
| Lucide React            | 아이콘             |

### 2.4 HTTP 및 Mocking

| 기술     | 용도                  |
|:-------|:--------------------|
| Axios  | HTTP 클라이언트, 인터셉터    |
| MSW v2 | API Mocking (명세 필수) |

### 2.5 개발 도구

| 기술       | 용도             |
|:---------|:---------------|
| ESLint   | 코드 품질 (명세 필수)  |
| Prettier | 코드 포맷팅 (명세 필수) |

---

## 3. 프로젝트 구조

### 3.1 설계 원칙

1. **페이지 단위 책임 분리**: 라우트와 1:1 매핑
2. **공통 UI 재사용**: Button, Input, Modal 등 분리
3. **API/상태 로직과 UI 분리**: hooks로 캡슐화
4. **과제 규모에 맞는 단순한 구조 유지**

### 3.2 폴더 구조

```
src/
├── app/                # 앱 초기화 및 라우터
│   ├── App.tsx
│   ├── Router.tsx
│   └── providers/
│
├── pages/              # 페이지 컴포넌트
│   ├── SignInPage.tsx
│   ├── DashboardPage.tsx
│   ├── TaskListPage.tsx
│   ├── TaskDetailPage.tsx
│   └── UserPage.tsx
│
├── components/         # 공통 UI 컴포넌트
│   ├── common/         # Button, Input, Modal, Card
│   ├── layout/         # AppLayout, GNB, ProtectedRoute
│   └── feedback/       # ErrorModal
│
├── hooks/              # 커스텀 훅
│   ├── useAuth.ts
│   ├── useDashboard.ts
│   ├── useTasks.ts     # 무한 스크롤
│   ├── useTask.ts
│   └── useUser.ts
│
├── api/                # API 클라이언트
│   ├── client.ts
│   └── endpoints.ts
│
├── contexts/           # React Context
│   └── AuthContext.tsx
│
├── utils/              # 유틸리티
│   └── validation.ts   # Zod 스키마
│
├── types/              # 타입 정의
├── styles/             # 전역 스타일, 토큰
├── constants/          # 상수 (routes, queryKeys)
└── mocks/              # MSW 핸들러
```

---

## 4. 상태 관리

### 4.1 상태 분류

| 상태 유형  | 관리 방식          | 예시                     |
|:-------|:---------------|:-----------------------|
| 서버 상태  | TanStack Query | 대시보드, 할 일 목록, 사용자 정보   |
| 전역 상태  | Zustand        | 인증 토큰, isAuthenticated |
| UI 상태  | useState       | 폼 입력값, 모달 열림 여부        |
| URL 상태 | React Router   | 현재 경로, 파라미터            |
| 파생 상태  | 계산             | isValid, hasNextPage   |

### 4.2 인증 상태

```typescript
interface AuthState {
    isAuthenticated: boolean;
    accessToken: string | null;
    refreshToken: string | null;

    login: (tokens: TokenPair) => void;
    logout: () => void;
}
```

- **토큰 저장**: localStorage (새로고침 시 로그인 유지)
- **returnUrl**: sessionStorage (로그인 후 원래 페이지 복귀)

### 4.3 서버 상태

```typescript
// 대시보드
const useDashboard = () => useQuery({
    queryKey: ['dashboard'],
    queryFn: fetchDashboard,
});

// 할 일 목록 (무한 스크롤) ✅ 명세 필수
const useTasks = () => useInfiniteQuery({
    queryKey: ['tasks'],
    queryFn: ({ pageParam = 1 }) => fetchTasks(pageParam),
    initialPageParam: 1,
    getNextPageParam: (lastPage, allPages) =>
        lastPage.length > 0 ? allPages.length + 1 : undefined,
});

// 할 일 상세
const useTask = (id: string) => useQuery({
    queryKey: ['task', id],
    queryFn: () => fetchTask(id),
});

// 사용자 정보
const useUser = () => useQuery({
    queryKey: ['user'],
    queryFn: fetchUser,
});
```

---

## 5. 가상 스크롤링 및 무한 스크롤

### 5.1 명세 요구사항

| 기능      | 명세 원문                                 |
|:--------|:--------------------------------------|
| 가상 스크롤링 | "화면에 보여지는 요소 또는 보여질 요소에 대해서만 적절히 렌더링" |
| 무한 스크롤  | "목록에 끝에 도달하는 경우 다음 페이지의 API를 호출"      |

### 5.2 구현 설계

```typescript
// TaskListPage.tsx
const TaskListPage = () => {
    const {
        data,
        fetchNextPage,
        hasNextPage,
        isFetchingNextPage,
    } = useTasks();

    const allTasks = data?.pages.flat() ?? [];

    return (
        <VirtualizedTaskList
            tasks={allTasks}
    onLoadMore={fetchNextPage}
    hasNextPage={hasNextPage}
    isLoading={isFetchingNextPage}
    />
);
};
```

```typescript
// VirtualizedTaskList.tsx
// @tanstack/react-virtual 사용
const VirtualizedTaskList = ({ tasks, onLoadMore, hasNextPage }) => {
    const parentRef = useRef<HTMLDivElement>(null);

    const virtualizer = useVirtualizer({
        count: tasks.length,
        getScrollElement: () => parentRef.current,
        estimateSize: () => 80, // 카드 높이
        overscan: 5,
    });

    // 스크롤 끝 감지 → 다음 페이지 로드
    useEffect(() => {
        const lastItem = virtualizer.getVirtualItems().at(-1);
        if (lastItem?.index >= tasks.length - 1 && hasNextPage) {
            onLoadMore();
        }
    }, [virtualizer.getVirtualItems(), hasNextPage]);

    return (
        <div ref={parentRef} style={{ height: '100%', overflow: 'auto' }}>
    {/* 가상화된 아이템 렌더링 */}
    </div>
);
};
```

---

## 6. 유효성 검증

### 6.1 명세 요구사항

| 필드   | 규칙                         |
|:-----|:---------------------------|
| 이메일  | RFC 이메일 규약 (필수)            |
| 비밀번호 | 영문, 한글, 숫자로 구성된 8~24자 (필수) |

> ⚠️ **주의**: 비밀번호는 **영문/한글/숫자만** 허용 (특수문자 불가)

### 6.2 Zod 스키마

```typescript
// utils/validation.ts
import { z } from 'zod';

export const signInSchema = z.object({
    email: z
        .string()
        .min(1, '이메일을 입력해주세요')
        .email('올바른 이메일 형식이 아닙니다'),

    password: z
        .string()
        .min(1, '비밀번호를 입력해주세요')
        .min(8, '비밀번호는 8자 이상이어야 합니다')
        .max(24, '비밀번호는 24자 이하여야 합니다')
        .regex(
            /^[a-zA-Z가-힣0-9]+$/,
            '비밀번호는 영문, 한글, 숫자만 사용 가능합니다'
        ),
});
```

### 6.3 버튼 상태

| 조건        | 버튼 상태 | 배경색               |
|:----------|:------|:------------------|
| 모든 유효성 통과 | 활성화   | `primary` (blue)  |
| 유효성 미통과   | 비활성화  | `disabled` (gray) |

---

## 7. API 클라이언트

### 7.1 Axios 인스턴스

```typescript
// api/client.ts
const client = axios.create({
    baseURL: '/api',
    timeout: 10000,
});
```

### 7.2 요청 인터셉터 (토큰 첨부)

```typescript
client.interceptors.request.use((config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});
```

### 7.3 응답 인터셉터 (401 처리 - 대시보드 제외)

> 💡 **설계 결정**: 대시보드(`/`)는 401 시 리다이렉트하지 않고 페이지 레벨에서 처리한다.

```typescript
client.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      const currentPath = window.location.pathname;
      
      // 💡 대시보드는 401 리다이렉트 제외 (랜딩 페이지)
      // 페이지 레벨에서 로그인 유도 UI 표시
      if (currentPath === '/') {
        return Promise.reject(error);
      }
      
      // 보호된 페이지: 즉시 리다이렉트
      // 1. 현재 경로 저장 (로그인 후 복귀용)
      sessionStorage.setItem('returnUrl', currentPath);
      // 2. 토큰 제거
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      // 3. 로그인 페이지로 즉시 이동
      window.location.href = '/sign-in';
    }
    return Promise.reject(error);
  }
);
```

### 7.4 API 함수

```typescript
// api/endpoints.ts
export const signIn = (data: SignInRequest) =>
  client.post('/sign-in', data).then(res => res.data);

export const fetchDashboard = () =>
  client.get('/dashboard').then(res => res.data);

export const fetchTasks = (page: number) =>
  client.get('/task', { params: { page } }).then(res => res.data);

export const fetchTask = (id: string) =>
  client.get(`/task/${id}`).then(res => res.data);

export const fetchUser = () =>
  client.get('/user').then(res => res.data);
```

---

## 8. 인증 및 라우팅

### 8.1 라우트 구성

> 💡 **설계 결정**: 대시보드는 비로그인 사용자도 접근 가능한 랜딩 페이지로 활용한다. 401 응답 시 리다이렉트 없이 로그인 유도 UI를 표시한다.

| 경로          | 인증 필요  | 401 처리 | 레이아웃               |
|:------------|:------:|:------|:-------------------|
| `/sign-in`  |   ❌    | -     | 단독 (GNB 미포함)       |
| `/`         |   💡    | 로그인 유도 UI | AppLayout (GNB 포함) |
| `/task`     |   ✅    | 즉시 리다이렉트 | AppLayout          |
| `/task/:id` |   ✅    | 즉시 리다이렉트 | AppLayout          |
| `/user`     |   ✅    | 즉시 리다이렉트 | AppLayout          |

- 💡 대시보드(`/`): 비로그인 접근 허용, 401 시 로그인 유도 UI 표시 (리다이렉트 없음)
- ✅ 보호된 페이지: 401 시 즉시 `/sign-in` 리다이렉트

### 8.2 ProtectedRoute (보호된 페이지 전용)

> 💡 대시보드(`/`)는 ProtectedRoute를 사용하지 않음. 페이지 레벨에서 401 처리.

```typescript
// 적용 대상: /task, /task/:id, /user (보호된 페이지)
// 제외 대상: / (대시보드 - 랜딩 페이지)
const ProtectedRoute = ({ children }: { children: React.ReactNode }) => {
  const { isAuthenticated } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    // 현재 경로 저장 → 로그인 후 복귀
    sessionStorage.setItem('returnUrl', location.pathname);
    return <Navigate to="/sign-in" replace />;
  }

  return <>{children}</>;
};
```

### 8.3 로그인 성공 후 리다이렉트

```typescript
// SignInPage.tsx
const handleLoginSuccess = (tokens: TokenPair) => {
  // 토큰 저장
  localStorage.setItem('accessToken', tokens.accessToken);
  localStorage.setItem('refreshToken', tokens.refreshToken);
  
  // 원래 페이지로 복귀 (없으면 대시보드)
  const returnUrl = sessionStorage.getItem('returnUrl') || '/';
  sessionStorage.removeItem('returnUrl');
  navigate(returnUrl);
};
```

### 8.4 GNB 상태 분기

| 인증 상태 | 표시 아이콘   | 클릭 동작         |
|:------|:---------|:--------------|
| 로그인됨  | 회원정보 아이콘 | `/user` 이동    |
| 비로그인  | 로그인 아이콘  | `/sign-in` 이동 |

---

## 9. 에러 처리 정책

### 9.1 상태 코드별 처리

> 💡 **설계 결정**: 대시보드(`/`)는 401 시 리다이렉트 없이 로그인 유도 UI를 표시한다.

| 코드   | 의미     | 페이지 유형 | 처리                           |
|:-----|:-------|:------|:-----------------------------|
| 200  | 성공     | 모든 페이지 | 정상 렌더링                       |
| 400  | 잘못된 요청 | 모든 페이지 | 에러 모달 (errorMessage 표시)      |
| 401  | 인증 실패  | 대시보드 | 💡 로그인 유도 UI 표시 (리다이렉트 없음) |
| 401  | 인증 실패  | 보호된 페이지 | 즉시 로그인 페이지 리다이렉트 (returnUrl 저장) |
| 404  | 리소스 없음 | 상세 페이지 | Not Found 화면 렌더링             |

### 9.2 페이지별 에러 처리

| 페이지         | 400 처리              | 401 처리    | 404 처리        |
|:------------|:--------------------|:----------|:--------------|
| `/sign-in`  | 에러 모달               | -         | -             |
| `/`         | -                   | 💡 로그인 유도 UI | -             |
| `/task`     | 에러 모달 + 목록 리다이렉트 버튼 | 즉시 리다이렉트 | -             |
| `/task/:id` | -                   | 즉시 리다이렉트 | Not Found 렌더링 |
| `/user`     | -                   | 즉시 리다이렉트 | -             |

### 9.3 에러 모달 사용

```typescript
// 로그인 페이지
<Modal isOpen={!!error} onClose={() => setError(null)} title="로그인 실패">
  {error?.response?.data?.errorMessage}
</Modal>

// 목록 페이지 (명세: "목록으로 redirect 하는 버튼" 제공)
<Modal isOpen={!!error} onClose={() => setErrorOpen(false)} title="오류 발생">
  {error?.response?.data?.errorMessage}
</Modal>
```

---

## 10. 삭제 확인 모달

### 10.1 명세 요구사항

> "삭제 버튼을 클릭 시, 삭제 여부를 확인하는 input을 포함한 모달을 생성"
> "input에 해당 id와 동일한 값을 기입한 후 제출 버튼을 클릭하면, 목록으로 redirect"
> "input에 해당 id와 동일한 값을 기입되지 않은 경우 제출 버튼은 비활성화"

### 10.2 구현 설계

```typescript
const DeleteConfirmModal = ({ isOpen, taskId, onClose, onConfirm }) => {
  const [inputValue, setInputValue] = useState('');
  const isMatch = inputValue === taskId;

  return (
    <Modal isOpen={isOpen} onClose={onClose}>
      <p>삭제하려면 <strong>{taskId}</strong>를 입력하세요.</p>
      <Input
        label="할 일 ID"
        value={inputValue}
        onChange={setInputValue}
      />
      <Button
        disabled={!isMatch}
        variant={isMatch ? 'primary' : 'disabled'}
        onClick={onConfirm}
      >
        제출
      </Button>
    </Modal>
  );
};
```

> 📌 **의사결정**: 명세에 DELETE API가 정의되어 있지 않으므로, 제출 시 **API 호출 없이** `/task`로 리다이렉트합니다.

---

## 11. 디자인 토큰

### 11.1 색상 (명세 필수)

```javascript
// tailwind.config.js
colors: {
  primary: '#3B82F6',    // blue - 활성화된 버튼
  disabled: '#9CA3AF',   // gray - 비활성화된 버튼
}
```

### 11.2 폰트 (명세 필수)

```css
font-family: 'Pretendard', sans-serif;
```

---

## 12. MSW Mocking

### 12.1 테스트 계정

| 항목 | 값 |
|:--|:--|
| 이메일 | test@example.com |
| 비밀번호 | password123 |

### 12.2 핸들러 구조

```
mocks/
├── handlers/
│   ├── auth.ts       # sign-in, refresh
│   ├── dashboard.ts
│   ├── task.ts       # 목록, 상세
│   └── user.ts
└── browser.ts
```

### 12.3 Task id 처리

> 📌 **의사결정**: 명세의 `/api/task` 응답에 id 필드가 없으나, 상세 페이지(`/task/:id`) 이동에 필수이므로 **MSW 응답에서 id 필드를 추가**합니다.

```typescript
// MSW 응답 예시
{
  id: 'task-1',        // Mock에서 추가
  title: '할 일 1',
  memo: '메모',
  status: 'TODO'
}
```

---

## 13. 의사결정 사항

> 명세에 명시되지 않아 구현 시 결정한 항목

| #    | 항목               | 결정                   | 근거                                 |
|:-----|:-----------------|:---------------------|:-----------------------------------|
| 1    | 대시보드 접근 권한      | 비로그인 허용 (랜딩 페이지)     | 원본 명세에 401 처리 미명시                  |
| 2    | 대시보드 401 처리     | 로그인 유도 UI (리다이렉트 없음) | 보호된 페이지와 차별화                       |
| 3    | 회원정보 페이지 경로      | `/user`              | 명세 미정의, 일반적인 관례                    |
| 4    | 로그인 페이지 레이아웃     | GNB 미포함              | 인증 전 상태, 로그인에 집중                   |
| 5    | Task 목록 id 필드    | MSW에서 추가             | 상세 페이지 이동에 필수                      |
| 6    | 토큰 저장 방식         | localStorage         | 새로고침 시 로그인 유지                      |
| 7    | 삭제 시 API 호출      | 미호출 (UI만 구현)         | DELETE API 명세 부재                   |
| 8    | 마지막 페이지 판단       | 응답 배열 길이             | 페이지네이션 메타 정보 없음                    |
| 9    | Refresh Token 사용 | 선택적 구현               | 명세에 API 정의됨, 구현은 선택                |
| 10   | 비밀번호 정책 해석       | 영문+한글+숫자로만 구성 필수     | 완성형 한글(가-힣)만 허용  |

---

## 14. 구현 체크리스트

### 14.1 필수 (명세 요구사항)

- [ ] 가상 스크롤링 구현
- [ ] 무한 스크롤 구현
- [ ] 이메일/비밀번호 유효성 검증
- [ ] 버튼 활성화/비활성화 (primary/disabled)
- [ ] 보호된 페이지 401 시 로그인 리다이렉트 + 원래 페이지 복귀
- [ ] 대시보드 401 시 로그인 유도 UI (리다이렉트 없음) 💡
- [ ] 삭제 확인 모달 (ID 입력 검증)
- [ ] 404 시 Not Found 렌더링
- [ ] MSW API Mocking
- [ ] ESLint + Prettier

### 14.2 권장 (UX 향상)

- [ ] 로딩 상태 표시
- [ ] 빈 목록 상태 UI
- [ ] 토큰 자동 갱신 (refresh)
